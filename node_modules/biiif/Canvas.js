"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const { basename, dirname, extname, join } = require('path');
const { existsSync, readFileSync } = require('fs');
const { glob } = require('glob');
const annotationBoilerplate = require('./boilerplate/annotation');
const chalk = require('chalk');
const config = require('./config');
const urljoin = require('url-join');
const yaml = require('js-yaml');
const Utils_1 = require("./Utils");
const Motivations_1 = require("./Motivations");
class Canvas {
    constructor(filePath, url) {
        this.infoYml = {};
        this.filePath = filePath;
        this.url = url;
    }
    create(canvasJson) {
        this.canvasJson = canvasJson;
        this._getMetadata();
        this._applyMetadata();
        // first, determine if there are any custom annotations (files ending in .yml that aren't info.yml)
        // if there are, loop through them creating the custom annotations.
        // if none of them has a motivation of 'painting', loop through all paintable file types adding them to the canvas.
        const customAnnotationFiles = glob.sync(this.filePath + '/*.yml', {
            ignore: [
                '**/info.yml'
            ]
        });
        let hasPaintingAnnotation = false;
        customAnnotationFiles.forEach((file) => {
            let directoryName = dirname(file);
            directoryName = directoryName.substr(directoryName.lastIndexOf('/'));
            const name = basename(file, extname(file));
            const annotationJson = Utils_1.Utils.cloneJson(annotationBoilerplate);
            const yml = yaml.safeLoad(readFileSync(file, 'utf8'));
            annotationJson.id = urljoin(canvasJson.id, 'annotation', canvasJson.items[0].items.length);
            let motivation = yml.motivation;
            if (!motivation) {
                // assume painting
                motivation = Motivations_1.Motivations.PAINTING;
                console.warn(chalk.yellow('motivation property missing in ' + file + ', guessed ' + motivation));
            }
            annotationJson.motivation = motivation;
            annotationJson.target = canvasJson.id;
            let id;
            // if the motivation is painting, or isn't recognised, set the id to the path of the yml value
            if ((motivation.toLowerCase() === Motivations_1.Motivations.PAINTING || !config.annotation.motivations[motivation]) && yml.value && extname(yml.value)) {
                hasPaintingAnnotation = true;
                id = urljoin(this.url.href, directoryName, yml.value);
            }
            else {
                id = urljoin(this.url.href, 'index.json', 'annotations', name);
            }
            annotationJson.body.id = id;
            if (yml.type) {
                annotationJson.body.type = yml.type;
            }
            else if (yml.value && extname(yml.value)) {
                // guess the type from the extension
                const type = Utils_1.Utils.getTypeByExtension(motivation, extname(yml.value));
                if (type) {
                    annotationJson.body.type = type;
                    console.warn(chalk.yellow('type property missing in ' + file + ', guessed ' + type));
                }
            }
            else if (yml.format) {
                // guess the type from the format
                const type = Utils_1.Utils.getTypeByFormat(motivation, yml.format);
                if (type) {
                    annotationJson.body.type = type;
                    console.warn(chalk.yellow('type property missing in ' + file + ', guessed ' + type));
                }
            }
            if (!annotationJson.body.type) {
                delete annotationJson.body.type;
                console.warn(chalk.yellow('unable to determine type of ' + file));
            }
            if (yml.format) {
                annotationJson.body.format = yml.format;
            }
            else if (yml.value && extname(yml.value) && yml.type) {
                // guess the format from the extension and type
                const format = Utils_1.Utils.getFormatByExtensionAndType(motivation, extname(yml.value), yml.type);
                if (format) {
                    annotationJson.body.format = format;
                    console.warn(chalk.yellow('format property missing in ' + file + ', guessed ' + format));
                }
            }
            else if (yml.value && extname(yml.value)) {
                // guess the format from the extension
                const format = Utils_1.Utils.getFormatByExtension(motivation, extname(yml.value));
                if (format) {
                    annotationJson.body.format = format;
                    console.warn(chalk.yellow('format property missing in ' + file + ', guessed ' + format));
                }
            }
            else if (yml.type) {
                // can only guess the format from the type if there is one typeformat for this motivation.
                const format = Utils_1.Utils.getFormatByType(motivation, yml.type);
                if (format) {
                    annotationJson.body.format = format;
                    console.warn(chalk.yellow('format property missing in ' + file + ', guessed ' + format));
                }
            }
            if (!annotationJson.body.format) {
                delete annotationJson.body.format;
                console.warn(chalk.yellow('unable to determine format of ' + file));
            }
            annotationJson.body.label = Utils_1.Utils.getLabel(this.infoYml.label);
            // if there's a value, and we're using a recognised motivation (except painting)
            if (yml.value && config.annotation.motivations[motivation] && motivation !== Motivations_1.Motivations.PAINTING) {
                annotationJson.body.value = yml.value;
            }
            canvasJson.items[0].items.push(annotationJson);
        });
        if (!hasPaintingAnnotation) {
            this._annotatePaintableFiles(canvasJson);
        }
        if (!canvasJson.items[0].items.length) {
            console.warn(chalk.yellow('Could not find any files to annotate onto ' + this.filePath));
        }
        // if there's no thumb.[jpg, gif, png] generate one from the first painted image
        Utils_1.Utils.getThumbnail(this.canvasJson, this.url, this.filePath);
    }
    _annotatePaintableFiles(canvasJson) {
        // for each jpg/pdf/mp4/obj in the canvas directory
        // add a painting annotation
        const paintableFiles = glob.sync(this.filePath + '/*.*', {
            ignore: [
                '**/thumb.*' // ignore thumbs
            ]
        });
        paintableFiles.forEach((file) => {
            const extName = extname(file);
            // if config.annotation has a matching extension
            let defaultPaintingExtension = config.annotation.motivations.painting[extName];
            let directoryName = dirname(file);
            directoryName = directoryName.substr(directoryName.lastIndexOf('/'));
            const fileName = basename(file);
            const id = urljoin(this.url.href, directoryName, fileName);
            if (defaultPaintingExtension) {
                defaultPaintingExtension = defaultPaintingExtension[0];
                const annotationJson = Utils_1.Utils.cloneJson(annotationBoilerplate);
                annotationJson.id = urljoin(canvasJson.id, 'annotation', canvasJson.items[0].items.length);
                annotationJson.motivation = Motivations_1.Motivations.PAINTING;
                annotationJson.target = canvasJson.id;
                annotationJson.body.id = id;
                annotationJson.body.type = defaultPaintingExtension.type;
                annotationJson.body.format = defaultPaintingExtension.format;
                annotationJson.body.label = Utils_1.Utils.getLabel(this.infoYml.label);
                canvasJson.items[0].items.push(annotationJson);
            }
        });
    }
    _getMetadata() {
        this.infoYml = {};
        // if there's an info.yml
        const ymlPath = join(this.filePath, 'info.yml');
        if (existsSync(ymlPath)) {
            this.infoYml = yaml.safeLoad(readFileSync(ymlPath, 'utf8'));
            console.log(chalk.green('got metadata for: ') + this.filePath);
        }
        else {
            console.log(chalk.green('no metadata found for: ') + this.filePath);
        }
        if (!this.infoYml.label) {
            // default to the directory name
            this.infoYml.label = basename(this.filePath);
        }
    }
    _applyMetadata() {
        this.canvasJson.label = Utils_1.Utils.getLabel(this.infoYml.label); // defaults to directory name
        if (this.infoYml.metadata) {
            this.canvasJson.metadata = Utils_1.Utils.formatMetadata(this.infoYml.metadata);
        }
    }
}
exports.Canvas = Canvas;
