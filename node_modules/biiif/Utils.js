"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// const fs = require('fs');
const { dirname } = require('path');
const { existsSync } = require('fs');
const { glob } = require('glob');
const { join } = require('path');
const chalk = require('chalk');
const config = require('./config');
const Jimp = require("jimp");
const labelBoilerplate = require('./boilerplate/label');
const thumbnailBoilerplate = require('./boilerplate/thumbnail');
const urljoin = require('url-join');
const Motivations_1 = require("./Motivations");
const Types_1 = require("./Types");
class Utils {
    static getTypeByExtension(motivation, extension) {
        const m = config.annotation.motivations[motivation];
        if (m) {
            if (m[extension] && m[extension].length) {
                return m[extension][0].type;
            }
        }
        return undefined;
    }
    static getFormatByExtension(motivation, extension) {
        const m = config.annotation.motivations[motivation];
        if (m) {
            if (m[extension] && m[extension].length) {
                return m[extension][0].format;
            }
        }
        return undefined;
    }
    static getFormatByExtensionAndType(motivation, extension, type) {
        const m = config.annotation.motivations[motivation];
        if (m) {
            if (m[extension] && m[extension].length) {
                const typeformats = m[extension];
                for (let i = 0; i < typeformats.length; i++) {
                    const typeformat = typeformats[i];
                    if (typeformat.type === type) {
                        return typeformat.format;
                    }
                }
            }
        }
        return undefined;
    }
    static getTypeByFormat(motivation, format) {
        const m = config.annotation.motivations[motivation];
        if (m) {
            for (const extension in m) {
                const typeformats = m[extension];
                for (let i = 0; i < typeformats.length; i++) {
                    const typeformat = typeformats[i];
                    if (typeformat.format === format) {
                        return typeformat.type;
                    }
                }
            }
        }
        return undefined;
    }
    static getFormatByType(motivation, type) {
        const m = config.annotation.motivations[motivation];
        // only able to categorically say there's a matching format 
        // if there's a single extension with a single type
        if (m) {
            if (Object.keys(m).length === 1) {
                const typeformats = m[Object.keys(m)[0]];
                if (typeformats.length === 1) {
                    return typeformats[0].format;
                }
            }
        }
        return undefined;
    }
    static timeout(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    static cloneJson(json) {
        return JSON.parse(JSON.stringify(json));
    }
    static formatMetadata(metadata) {
        const formattedMetadata = [];
        for (let key in metadata) {
            if (metadata.hasOwnProperty(key)) {
                const value = metadata[key];
                const item = {};
                item.label = Utils.getLabel(key);
                item.value = Utils.getLabel(value);
                formattedMetadata.push(item);
            }
        }
        return formattedMetadata;
    }
    static hasManifestsYML(filePath) {
        const manifestsPath = join(filePath, 'manifests.yml');
        return existsSync(manifestsPath);
    }
    static getThumbnail(json, url, filePath) {
        const thumbnailPattern = filePath + '/thumb.*';
        const thumbnails = glob.sync(thumbnailPattern);
        if (thumbnails.length) {
            console.log(chalk.green('found thumbnail for: ') + filePath);
            let thumbnail = thumbnails[0];
            const thumbnailJson = Utils.cloneJson(thumbnailBoilerplate);
            thumbnailJson[0].id = Utils.mergePaths(url, thumbnail);
            json.thumbnail = thumbnailJson;
        }
        else {
            // generate thumbnail
            if (json.items && json.items.length && json.items[0].items) {
                console.log(chalk.green('generating thumbnail for: ') + filePath);
                // find an annotation with a painting motivation of type image.
                const items = json.items[0].items;
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    const body = item.body;
                    if (body && item.motivation === Motivations_1.Motivations.PAINTING) {
                        if (body.type.toLowerCase() === Types_1.Types.IMAGE) {
                            const imageName = body.id.substr(body.id.lastIndexOf('/'));
                            const imagePath = join(filePath, imageName);
                            Jimp.read(imagePath).then((image) => {
                                const thumb = image.clone();
                                // write image buffer to disk for testing
                                // image.getBuffer(Jimp.AUTO, (err, buffer) => {
                                //     const arrBuffer = [...buffer];
                                //     const pathToBuffer: string = imagePath.substr(0, imagePath.lastIndexOf('/')) + '/buffer.txt';
                                //     fs.writeFile(pathToBuffer, arrBuffer);
                                // });
                                thumb.cover(config.thumbnails.width, config.thumbnails.height);
                                const pathToThumb = join(dirname(imagePath), 'thumb.' + image.getExtension());
                                thumb.write(pathToThumb, () => {
                                    console.log(chalk.green('generated thumbnail for: ') + filePath);
                                });
                                const thumbnailJson = Utils.cloneJson(thumbnailBoilerplate);
                                thumbnailJson[0].id = Utils.mergePaths(url, pathToThumb);
                                json.thumbnail = thumbnailJson;
                            }).catch(function (err) {
                                //console.log(chalk.red(err));
                                console.warn(chalk.yellow('unable to generate thumbnail for: ') + filePath);
                            });
                        }
                    }
                }
            }
        }
    }
    static getLabel(value) {
        const labelJson = Utils.cloneJson(labelBoilerplate);
        labelJson['@none'].push(value);
        return labelJson;
    }
    /*
        merge these two example paths:
        url:        http://test.com/collection/manifest
        filePath:   c:/user/documents/collection/manifest/_canvas/thumb.png

        into:       http://test.com/collection/manifest/_canvas/thumb.png
    */
    static mergePaths(url, filePath) {
        // split the url (minus origin) and filePath into arrays
        //                            ['collection', 'manifest']
        // ['c:', 'user', 'documents', 'collection', 'manifest', '_canvas', 'thumb.jpg']
        // walk backwards through the filePath array adding to the newPath array until the last item of the url array is found.
        // then while the next url item matches the next filePath item, add it to newPath.
        // the final path is the url origin plus a reversed newPath joined with a '/'
        let origin = url.origin;
        let urlParts;
        if (url.protocol === 'dat:') {
            origin = 'dat://';
            urlParts = url.href.replace(origin, '').split('/');
        }
        else {
            urlParts = url.href.replace(origin + '/', '').split('/');
        }
        filePath = filePath.replace(/\\/g, '/');
        const fileParts = filePath.split('/');
        const newPath = [];
        for (let f = fileParts.length - 1; f >= 0; f--) {
            const filePart = fileParts[f];
            newPath.push(filePart);
            if (filePart === urlParts[urlParts.length - 1]) {
                if (urlParts.length > 1) {
                    for (let u = urlParts.length - 2; u >= 0; u--) {
                        f--;
                        if (fileParts[f] === urlParts[u]) {
                            newPath.push(fileParts[f]);
                        }
                        else {
                            newPath.push(urlParts[u]);
                        }
                    }
                }
                break;
            }
        }
        let id = urljoin(origin, ...newPath.reverse());
        return id;
    }
}
exports.Utils = Utils;
